/** * * Copyright (c) 2010 - 2013, http://sgmnt.org/ *  * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * */package org.sgmnt.lib.net{        import flash.display.DisplayObject;    import flash.display.Loader;    import flash.display.LoaderInfo;    import flash.events.Event;    import flash.events.IOErrorEvent;    import flash.events.OutputProgressEvent;    import flash.events.ProgressEvent;    import flash.events.SecurityErrorEvent;    import flash.filesystem.File;    import flash.filesystem.FileMode;    import flash.filesystem.FileStream;    import flash.net.URLLoader;    import flash.net.URLLoaderDataFormat;    import flash.net.URLRequest;    import flash.system.LoaderContext;    import flash.utils.ByteArray;    import flash.utils.Dictionary;    import flash.utils.escapeMultiByte;        /**     * AIR に HTTP 経由で関連ファイルを読み込む際に使用するクラスです.     * HTTP 経由でリクエストした際に、読み込んだファイルをアプリケーションディレクトリ内のフォルダ内に保存してから読み込みます.     * HTTP リクエストに失敗した場合でも、ローカルに一度でも保存された事があればそのファイルを読み込みます.     * @author sgmnt.org     */    public class LocalCacheLoader extends Loader{                // ------- MEMBER -----------------------------------------------------------------                private var _context:LoaderInfo;        private var _workingDirectory:File;		private var _loadRemoteFileFirst:Boolean;		private var _remoteFileChecked:Boolean;                // ------- PUBLIC -----------------------------------------------------------------                /**         * Constructor.         * @param context 読み込み元への参照.基本的には this.loaderInfo を渡しておけば良いはず.         * @param loadRemoteFileFirst ネット上のファイルではなくローカルに保存したファイルを優先的に読み込むかどうか.         */		        public function LocalCacheLoader( context:LoaderInfo = null, loadRemoteFileFirst:Boolean = false ){                        super();						if( !LocalCacheSettings.WORKING_DIRECTORY ){				LocalCacheSettings.WORKING_DIRECTORY = File.applicationDirectory.resolvePath("/cache/__http__");			}						_context             = context || LocalCacheSettings.DEFAULT_CONTEXT;			_workingDirectory    = LocalCacheSettings.WORKING_DIRECTORY;			_loadRemoteFileFirst = loadRemoteFileFirst;						_remoteFileChecked   = false;			        }                // ------- PROTECTED -----------------------------------------------------------------        		/**		 * ファイルの読み込みを行います.		 * request の URL に http から始まるロケーションを指定した場合,そのファイルを AIR のアプリケーションディレクトリに保存してから読み込みます.		 * @param request		 * @param loaderContext		 */		override public function load( request:URLRequest, loaderContext:LoaderContext = null ):void{			if( _loadRemoteFileFirst ){				//trace("Load remote file first.");				_loadRemoteFile( request, loaderContext );			}else{				//trace("Load local file first.");				_loadLocalFile( request, loaderContext );			}		}		        // ------- PRIVATE -----------------------------------------------------------------                /**         * SWFファイルを読み込みます.         * @param filepath         */        private function _load( req:URLRequest, loaderContext:LoaderContext = null ):void{            //trace( "Load local file :: " + req.url );            super.load( req, loaderContext );        }                /**         * ローカル上のファイルの読み込みを試み,存在しなければリモートのファイルを取得します.         * @param request         */        private function _loadLocalFile( request:URLRequest, loaderContext:LoaderContext = null ):void{			var f:File;			var url:String = request.url;			if( url.indexOf("http") == 0 ){				// http リクエストの場合キャッシュディレクトリを調べる.				url = LocalCacheSettings.encode(url);				f   = new File( _workingDirectory.resolvePath( url.substring( url.indexOf("://") + 3, url.length ) ).nativePath );				if( f.exists ){					_load( new URLRequest( f.url ), loaderContext );				}else{					//trace("Local file does not exists.");					if( !_remoteFileChecked ){						_loadRemoteFile( request, loaderContext );					}else{						// Event を通知すると　Unhandled Error が起きてしまうので,絶対に存在しないファイルを読み込む						_load( new URLRequest( 'error:/errorrrrrrrrrrrr!!!!!/' ) );					}				}			}else{				if( _context ){					f = new File( _context.url );					if(f.isDirectory){						request.url = f.resolvePath(request.url).url;					}else{						request.url = f.resolvePath('../'+request.url).url;					}				}				// 相対パスリクエストの場合通常通りのリクエストを行う.				_load( request, loaderContext );			}        }                /**         * リモートのファイルをローカルに読み込み保存します.         * ネットワークアクセスに失敗した場合は,ローカルのファイルの読み込みを試みます.         * @param request         * @param loaderContext         */        private function _loadRemoteFile( request:URLRequest, loaderContext:LoaderContext = null ):void{						var url:String = request.url;						// 読み込み元が存在し、かつそのURL が _workingDirectory から始まっていた場合.			// つまり元々のリモートに存在したが、現在はローカルに存在する.というものはそこからの相対パスに直す.			if( request.url.indexOf('http') != 0 && _context && -1 < _context.url.indexOf(_workingDirectory.url) ){				var url2 = _context.url;				url2 = url2.replace(_workingDirectory.url,"http:/");				url2 = url2.substr( 0, url2.lastIndexOf("/") ) + "/" + request.url;				url2 = LocalCacheSettings.decode(url2);				request.url = url2;			}else{				url = request.url;			}						if( url.indexOf("http") == 0 ){								url = LocalCacheSettings.encode(url);                                var filename:String = url.substring( url.lastIndexOf("/") + 1, url.length );                var filepath:String = url.substring( url.indexOf("://") + 3, url.lastIndexOf("/") );								// 読み込み失敗時の処理.				var onerror:Function = function(e:Event){					//trace(e);					_loadLocalFile( request, loaderContext );				}								// 読み込み成功時の処理.				var oncomplete:Function = function(e:Event){										//trace(e);										//trace("Create cache file...");										var f:File   = new File( _workingDirectory.resolvePath( filepath + "/" + filename ).nativePath );					var tmp:File = new File( _workingDirectory.resolvePath( filepath + "/" + filename +".tmp").nativePath );					var fs:FileStream = new FileStream();										if( f.exists ){						f.copyTo( tmp, true );					}										try{						fs.open(f,FileMode.WRITE);						fs.writeBytes( urlLoader.data as ByteArray );						fs.close();						if( tmp.exists ){							tmp.deleteFile();						}						//trace("Complete.");					}catch(e){						//trace(e);						//trace("Failure.");						if( tmp.exists ){							//trace("Rollback from temporary copy.");							tmp.moveTo( f, true );						}					}										_loadLocalFile( request, loaderContext );									}                				//trace( "Load remote file :: " + request.url );								_remoteFileChecked = true;								var urlLoader:URLLoader = new URLLoader();				urlLoader.dataFormat = URLLoaderDataFormat.BINARY;                urlLoader.addEventListener( Event.COMPLETE, oncomplete );                urlLoader.addEventListener( IOErrorEvent.IO_ERROR, onerror );                urlLoader.addEventListener( SecurityErrorEvent.SECURITY_ERROR, onerror );                urlLoader.load( request );                            }else{                                _load( request, loaderContext );                            }                    }            }    }